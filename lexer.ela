import map::*;
import fmt::*;
import fs::*;
import interned::*;
alias InternedString :: Interned!<String>;

TType :: enum {
  Eof = -1,
  Identifier,
  Integer,
  Float,
  String,
  Char,

  Assign,
  Add,
  Sub,
  Mul,
  Div,
  Modulo,
  Range,
  Arrow,
  Comma,
  Semi,

  Not,
  LogicalNot,
  Or,
  And,
  SHL,
  SHR,
  Xor,
  LogicalOr,
  LogicalAnd,
  LT,
  GT,
  EQ,
  NEQ,
  LE,
  GE,
  LParen,
  RParen,
  LCurly,
  RCurly,
  LBrace,
  RBrace,
  DoubleColon,
  Dot,

  Increment,
  Decrement,

  Return,
  Break,
  Continue,
  For,
  While,
  If,
  Else,

  CompAdd,
  CompSub,
  CompMul,
  CompDiv,
  CompMod,
  CompAnd,
  CompOr,
  CompXor,
  CompSHL,
  CompSHR,

  True,
  False,
  Null,
  Varargs,
  Directive,   // #
  ColonEquals, //  :=

  Struct,
  Enum,
  Union,

  Then,
  Colon,
  In,

  Switch,
  Fn,

  GenericBrace,   // '!<' for ![T, T1]
  As,             // 'as' for casting
  ExpressionBody, // => for expr body, implicit return expr where a block was otherwise expected.
  Defer,

  Impl,      // impl
  Interface, // interface
  Where,

  Size_Of,
  Type_Of,

  Alias,
  Import,
  Module,

  Attribute,

  Mut,
  Const
}

init_ttype_lut :: fn() -> Map!<u64, str> {
  type := typeof(TType);
  mut lut: Map!<u64, str>;
  for field in type.fields {
    lut.insert(field.enum_value, field.name);
  }
  return lut;
}

ttype_to_string :: fn(type: TType) -> str {
  #static mut lut: *mut Map!<u64, str>;
  if !lut {
    lut = new(init_ttype_lut());
  }
  return lut.get(type).unwrap();
}

SourceLocation :: struct {
  line: u64,
  column: u64,
  file: u64,
}

impl SourceLocation {
  #static files :: fn() -> *mut List!<String> {
    #static mut files: List!<String>;
    return &mut files;
  }

  to_string :: fn(self) -> String {
    filename := SourceLocation::files()[self.file];
    return format("%:%:%", (filename, self.line, self.column), FormatOptions::default());
  }
}

Token :: struct {
  value: InternedString,
  type: TType,
  location: SourceLocation,
}

impl Token {
  is_relational :: fn(self) -> bool{
    return switch self.type {
      TType::LT => true,
      TType::GT => true,
      TType::EQ => true,
      TType::NEQ => true,
      TType::LE => true,
      TType::GE => true,
      TType::LogicalOr => true,
      TType::LogicalAnd => true,
      else => false,
    }
  }

  is_comp_assign :: fn(self) -> bool  {
    return self.type == TType::CompAdd || self.type == TType::CompSub || self.type == TType::CompMul || self.type == TType::CompDiv ||
           self.type == TType::CompMod || self.type == TType::CompAnd || self.type == TType::CompOr || self.type == TType::CompXor ||
           self.type == TType::CompSHL || self.type == TType::CompSHR;
  }

  Eof :: fn() -> Token {
    #static eof: Token = .{
      type: TType::Eof,
    };
    return eof;
  }

  is_type :: fn(self, type: TType) -> bool {
    return self.type == type;
  }

  is_eof :: fn(self) -> bool {
    return self.type == TType::Eof;
  }

  new :: fn(location: SourceLocation, value: String, type: TType) -> Token {
    return .{
      value: InternedString::new(value),
      type: type,
      location: location,
    };
  }
};

init_operator_and_keyword_maps :: fn(operators: *mut Map!<str, TType>, keywords: *mut Map!<str, TType>) {
  keywords.insert("const", TType::Const);
  keywords.insert("mut", TType::Mut);
  keywords.insert("module", TType::Module);
  keywords.insert("import", TType::Import);
  keywords.insert("alias", TType::Alias);
  keywords.insert("in", TType::In);
  keywords.insert("where", TType::Where);
  keywords.insert("sizeof", TType::Size_Of);
  keywords.insert("typeof", TType::Type_Of);
  keywords.insert("fn", TType::Fn);
  keywords.insert("switch", TType::Switch);
  keywords.insert("then", TType::Then);
  keywords.insert("return", TType::Return);
  keywords.insert("break", TType::Break);
  keywords.insert("continue", TType::Continue);
  keywords.insert("for", TType::For);
  keywords.insert("while", TType::While);
  keywords.insert("if", TType::If);
  keywords.insert("else", TType::Else);
  keywords.insert("struct", TType::Struct);
  keywords.insert("union", TType::Union);
  keywords.insert("enum", TType::Enum);
  keywords.insert("true", TType::True);
  keywords.insert("false", TType::False);
  keywords.insert("null", TType::Null);
  keywords.insert("as", TType::As);
  keywords.insert("impl", TType::Impl);
  keywords.insert("defer", TType::Defer);
  keywords.insert("interface", TType::Interface);

  operators.insert("=>", TType::ExpressionBody);
  operators.insert(":", TType::Colon);
  operators.insert("@", TType::Attribute);
  operators.insert(":=", TType::ColonEquals);
  operators.insert("...", TType::Varargs);
  operators.insert("#", TType::Directive);
  operators.insert(".", TType::Dot);
  operators.insert("!", TType::LogicalNot);
  operators.insert("~", TType::Not);
  operators.insert("::", TType::DoubleColon);
  operators.insert("->", TType::Arrow);
  operators.insert("..", TType::Range);
  operators.insert("+", TType::Add);
  operators.insert("-", TType::Sub);
  operators.insert("*", TType::Mul);
  operators.insert("/", TType::Div);
  operators.insert("%", TType::Modulo);
  operators.insert("=", TType::Assign);
  operators.insert(",", TType::Comma);
  operators.insert(";", TType::Semi);
  operators.insert("(", TType::LParen);
  operators.insert(")", TType::RParen);
  operators.insert("{", TType::LCurly);
  operators.insert("}", TType::RCurly);
  operators.insert("|", TType::Or);
  operators.insert("&", TType::And);
  operators.insert("||", TType::LogicalOr);
  operators.insert("&&", TType::LogicalAnd);
  operators.insert("<<", TType::SHL);
  operators.insert("^", TType::Xor);
  operators.insert("<", TType::LT);
  operators.insert(">", TType::GT);
  operators.insert("==", TType::EQ);
  operators.insert("!=", TType::NEQ);
  operators.insert("<=", TType::LE);
  operators.insert(">=", TType::GE);
  operators.insert("[", TType::LBrace);
  operators.insert("]", TType::RBrace);
  operators.insert("++", TType::Increment);
  operators.insert("--", TType::Decrement);
  operators.insert("+=", TType::CompAdd);
  operators.insert("-=", TType::CompSub);
  operators.insert("*=", TType::CompMul);
  operators.insert("/=", TType::CompDiv);
  operators.insert("%=", TType::CompMod);
  operators.insert("&=", TType::CompAnd);
  operators.insert("|=", TType::CompOr);
  operators.insert("^=", TType::CompXor);
  operators.insert("<<=", TType::CompSHL);
  operators.insert(">>=", TType::CompSHR);
  operators.insert("!<", TType::GenericBrace);

}

get_reserved_words :: fn() -> List!<str> {
  return List!<str>::init(.["auto", "break", "case", "const", "default",  "do",
                            "double", "else", "enum", "extern", "float", "for", "goto",
                            "int", "long", "return", "short", "signed",
                            "struct", "typedef", "unsigned", "volatile"]);
}

State :: struct {
  input: String,
  path: String,
  lookahead_buffer: List!<Token>,
  pos: u64,
  col: u64,
  line: u64,
  file_idx: u64,
}

impl State {
  new :: fn(path: String, input: String, file_idx: u64) -> #self {
    return .{
      path: path,
      input: input,
      file_idx: file_idx,
      pos: 0,
      col: 1,
      line: 1,
    };
  }

  from_file :: fn(filename: String) -> #self {
      canonical := canonical_path(filename).unwrap();
      parent := parent_path(canonical).unwrap();
      change_directory(parent).unwrap();
      input := File::read_all(canonical).unwrap();

      mut found := false;
      mut file_idx := 0;
      for file in *SourceLocation::files() {
        if file == canonical {
          found = true;
          break;
        } 
        file_idx++;
      }
      if (!found) {
        SourceLocation::files().push(canonical);
      }
      return State::new(canonical, input, file_idx);
    }
}

Lexer :: struct {
  operators: Map!<str, TType>,
  keywords: Map!<str, TType>,
  reserved: List!<str>,
}

impl Lexer {
  new :: fn() -> #self {
    mut self: #self;
    init_operator_and_keyword_maps(&mut self.operators, &mut self.keywords);
    self.reserved = get_reserved_words();
    return self;
  }
}

impl Lexer {
  get_token :: fn(*mut self, state: *mut State) {
    mut token_builder: StringBuilder;
    defer token_builder.deinit();
    
    while state.pos < state.input.length {
      token_builder.clear();
      mut c: u8 = state.input[state.pos];

      if c == '\n' {
        state.pos++;
        state.line++;
        state.col = 1;
        continue;
      }

      if c == ' ' || c == '\t' {
        state.pos++;
        state.col++;
        continue;
      }

      if c == '/' && state.pos + 1 < state.input.length && state.input[state.pos + 1] == '/' {
        state.pos += 2;
        state.col += 2;
        while c != '\n' && state.pos < state.input.length {
          state.pos++;
          c = state.input[state.pos];
        }
        if state.pos < state.input.length {
          state.pos++;
          state.col = 1;
          state.line++;
        }
        continue;
      }

      if c == '/' && state.pos + 1 < state.input.length && state.input[state.pos + 1] == '*' {
        state.pos += 2;
        state.col += 2;
        while state.pos + 1 < state.input.length && (state.input[state.pos] != '*' && state.input[state.pos + 1] != '/') {
          if state.input[state.pos] == '\n' {
            state.line++;
            state.col = 1;
          } else {
            state.col++;
          }
          state.pos++;
          c = state.input[state.pos];
        }
        if state.pos < state.input.length {
          state.pos += 2;
          state.col += 2;
        }
      }

      mut location : SourceLocation = .{
        line: state.line, 
        column: state.col, 
        file: state.file_idx
      };

      // Characters.
      if c == '\'' {
        start := state.pos;
        state.pos++;
        state.col++;
        c = state.input[state.pos];
        mut codepoint: u32 = -1;

        // Escape characters.
        if c == '\\' {
          state.pos++;
          state.col++;
          c = state.input[state.pos];
          state.pos++;
          state.col++;
          if c == 'n' {
            codepoint = '\n';
          } else if c == 'v' {
            codepoint = '\v';
          } else if c == 'b' {
            codepoint = '\b';
          } else if c == 't' {
            codepoint = '\t';
          } else if c == 'f' {
            codepoint = '\f';
          } else if c == 'r' {
            codepoint = '\r';
          } else if c == '\'' {
            codepoint = '\'';
          } else if c == '\\' {
            codepoint = '\\';
          } else if c == '\"' {
            codepoint = '\"';
          } else if c == '0' {
            codepoint = '\0';
          } else if c == 'x' || c == 'u' || c == 'U' {
            mut num_digits: u64;
            if c == 'x' {
              num_digits = 2;
            } else if c == 'u' {
              num_digits = 4;
            } else {
              num_digits = 8;
            }
            state.pos++;
            state.col++;
            codepoint = 0;
            for i in 0..num_digits {
              if (state.pos >= state.input.length || !isxdigit(state.input[state.pos])) {
                // ! reimplement throw_error.
                // ! throw_error("invalid hexadecimal escape sequence", {location});
                panic("failurezorz");
              }
              buffer: u8[2] = .[
                state.input[state.pos],
                '\0',
              ];
              mut hex_value: u8 = state.input[state.pos];
              if hex_value >= '0' && hex_value <= '9' {
                hex_value -= '0';
              } else if hex_value >= 'a' && hex_value <= 'f' {
                hex_value -= 'a' - 10;
              } else if hex_value >= 'A' && hex_value <= 'F' {
                hex_value -= 'A' - 10;
              }
              codepoint = (codepoint << 4) | hex_value;
              state.pos++;
              state.col++;
            }
          } else if c >= '0' && c <= '7' { // Octal escape sequence
            codepoint = 0;
            mut i := 0;
            while i < 3 && c > '0' && c < '7' {
              codepoint = (codepoint << 3) | (c - '0');
              state.pos++;
              state.col++;
              c = state.input[state.pos];
              ++i;
            }
          } else {
            // ! reimplement throw_error
            // throw_error(std::format("invalid escape sequence {}", c), {location});
            panic("failed to get hex escape char");
          }
        } else if (c & 0x80) == 0 {
          codepoint = c;
          state.pos++;
          state.col++;
        } else {
          mut num_bytes := 0;
          if ((c & 0xE0) == 0xC0) {
            num_bytes = 2;
          }
          else if ((c & 0xF0) == 0xE0) {
            num_bytes = 3;
          }
          else if ((c & 0xF8) == 0xF0) {
            num_bytes = 4;
          }
          else {
            // ! reimplement throw_error;
            panic("invalid utf8 char");
          }

          for i in 0..num_bytes {
            if (state.pos >= state.input.length || (i > 0 && (state.input[state.pos] & 0xC0) != 0x80)) {
              // ! reimplement throw_error;
              panic("invalid UTF-8 continuation byte");
              // throw_error("invalid UTF-8 continuation byte", {location});
            }
            codepoint = (codepoint << 6) | (state.input[state.pos] & 0x3F);
            state.pos++;
            state.col++;
          }

          c = state.input[state.pos];
          if (c != '\'') {
            // ! reimplement throw_error;
            panic("invalid char literal: too many characters {}");
            // throw_error(std::format("invalid char literal: too many characters {}", codepoint), {location});
          }
          state.pos++; // move past '
          state.col++;
          mut buffer: u8[32];
          snprintf(buffer, 32 * sizeof(u8), "0x%X"c, codepoint);
          state.lookahead_buffer.push(Token::new(location, String::from_ptr(buffer), TType::Char));
        }
      }
    }

    state.lookahead_buffer.push(Token::Eof());
  }
}


// impl Lexer {
//   get_token :: fn(state: State) {
// {
//   size_t &pos = state.pos;
//   const std::string &input = state.input;
//   const size_t len = state.input_len;
//   size_t &lines = state.line;
//   size_t &col = state.col;
//   std::stringstream token;

//   while (pos < len) {
//     token.clear();

//     char c = input[pos];

//     if (c == '\n') {
//       pos++;
//       lines++;
//       col = 1; // Reset column position at the start of a new line
//       continue;
//     }

//     if (c == ' ' || c == '\t') {
//       pos++;
//       col++;
//       continue;
//     }

//     // single comment
//     if (c == '/' && pos + 1 < len && input[pos + 1] == '/') {
//       pos += 2;
//       col += 2;
//       size_t newlinePos = input.find('\n', pos);
//       if (newlinePos != std::string::npos) {
//         lines++;
//         col = 1; // Reset column position at the start of a new line
//         pos = newlinePos + 1;
//       } else {
//         pos = len;
//       }
//       continue;
//     }

//     // multi line comment
//     if (c == '/' && pos + 1 < len && input[pos + 1] == '*') {
//       pos += 2;
//       col += 2;
//       while (pos + 1 < len && !(input[pos] == '*' && input[pos + 1] == '/')) {
//         if (input[pos] == '\n') {
//           lines++;
//           col = 1; // Reset column position at the start of a new line
//         } else {
//           col++;
//         }
//         pos++;
//       }
//       pos += 2;
//       col += 2;
//       continue;
//     }

//     SourceLocation location{state.line, state.col, state.file_idx};

//     if (c == '\'') {
//         auto start = pos;
//         pos++; // move past '
//         col++;
//         c = input[pos];
//         uint32_t codepoint = 0;
    
//         if (c == '\\') {
//             // Handle escape sequences
//             pos++;
//             col++;
//             c = input[pos];
//             pos++;
//             col++;
//             switch (c) {
//                 case 'n': codepoint = '\n'; break;
//                 case 'v': codepoint = '\v'; break;
//                 case 'b': codepoint = '\b'; break;
//                 case 't': codepoint = '\t'; break;
//                 case 'f': codepoint = '\f'; break;
//                 case 'r': codepoint = '\r'; break;
//                 case '\\': codepoint = '\\'; break;
//                 case '\'': codepoint = '\''; break;
//                 case '\"': codepoint = '\"'; break;
//                 case '0': codepoint = '\0'; break;
//                 case 'x':
//                 case 'u':
//                 case 'U': {
//                     int num_digits = (c == 'x') ? 2 : (c == 'u') ? 4 : 8;
//                     pos++;
//                     col++;
//                     codepoint = 0;
//                     for (int i = 0; i < num_digits; ++i) {
//                         if (pos >= input.size() || !std::isxdigit(input[pos])) {
//                             throw_error("invalid hexadecimal escape sequence", {location});
//                         }
//                         codepoint = (codepoint << 4) | std::stoi(std::string(1, input[pos]), nullptr, 16);
//                         pos++;
//                         col++;
//                     }
//                     break;
//                 }
//                 default:
//                     if (c >= '0' && c <= '7') { // Octal escape sequence
//                         codepoint = 0;
//                         for (int i = 0; i < 3 && c >= '0' && c <= '7'; ++i) {
//                             codepoint = (codepoint << 3) | (c - '0');
//                             pos++;
//                             col++;
//                             c = input[pos];
//                         }
//                     } else {
//                         throw_error(std::format("invalid escape sequence {}", c), {location});
//                     }
//                     break;
//             }
//         } else if (DOESNT_HAVE_FLAG(c, 0x80)) {
//             // ASCII character
//             codepoint = c;
//             pos++;
//             col++;
//         } else {
//             // UTF-8 character
//             int num_bytes = 0;
//             if ((c & 0xE0) == 0xC0)
//                 num_bytes = 2;
//             else if ((c & 0xF0) == 0xE0)
//                 num_bytes = 3;
//             else if ((c & 0xF8) == 0xF0)
//                 num_bytes = 4;
//             else
//                 throw_error("invalid UTF-8 start byte", {location});
    
//             for (int i = 0; i < num_bytes; ++i) {
//                 if (pos >= input.size() || (i > 0 && (input[pos] & 0xC0) != 0x80)) {
//                     throw_error("invalid UTF-8 continuation byte", {location});
//                 }
//                 codepoint = (codepoint << 6) | (input[pos] & 0x3F);
//                 pos++;
//                 col++;
//             }
//         }
    
//         c = input[pos];
//         if (c != '\'') {
//             throw_error(std::format("invalid char literal: too many characters {}", codepoint), {location});
//         }
//         pos++; // move past '
//         col++;
    
//         std::stringstream ss;
//         ss << "0x" << std::hex << codepoint;
//         state.lookahead_buffer.push_back(Token(location, ss.str(), TType::Char, TFamily::Literal));
//         return;
//     }

//     if (c == '"') {
//       pos++;
//       col++;
//       c = input[pos];
//       while (pos < len) {
//         c = input[pos];
//         if (c == '"') {
//           break;
//         } if (c == '\n') {
//           throw_error("You can't directly embed a '\\n' in string by just letting it span multiple lines", {location});
//         } else if (c == '\\') {
//           if (pos + 1 < len) {
//             token.put(c);
//             pos++;
//             col++;
//             token.put(input[pos]);
//             pos++;
//             col++;
//           } else {
//             throw_error("incomplete escape sequence at end of input", {location});
//           }
//         } else {
//           token.put(c);
//           pos++;
//           col++;
//           c = input[pos];
//         }
//       }
//       pos++;
//       col++;
//       state.lookahead_buffer.push_back(Token(location, token.str(), TType::String, TFamily::Literal));
//       return;
//     }

//     if (std::isalpha(c) || c == '_' ||
//         (c & 0x80) != 0) { // Check if the character is alphabetic, underscore, or a UTF-8 start byte
//       while (pos < len) {
//         if (std::isalnum(c) || c == '_') {
//           token << c;
//           pos++;
//           col++;
//           c = input[pos];
//         } else if (HAS_FLAG(c, 0x80)) { // Check if the character is a UTF-8 start byte
//           int num_bytes = 0;
//           if ((c & 0xE0) == 0xC0)
//             num_bytes = 2;
//           else if ((c & 0xF0) == 0xE0)
//             num_bytes = 3;
//           else if ((c & 0xF8) == 0xF0)
//             num_bytes = 4;
//           else
//             break; // Stop processing if it's not a valid UTF-8 start byte

//           for (int i = 0; i < num_bytes; ++i) {
//             if (pos >= len || (i > 0 && (input[pos] & 0xC0) != 0x80)) {
//               break; // Stop processing if it's not a valid UTF-8 continuation byte
//             }
//             token << input[pos];
//             pos++;
//             col++;
//           }

//           c = input[pos];
//         } else {
//           break; // Stop processing if it's not a valid identifier character
//         }
//       }

//       string value = token.str();
//       if (keywords.contains(value)) {
//         state.lookahead_buffer.push_back(Token(location, value, keywords.at(value), TFamily::Keyword));
//       } else {
//         if (reserved.contains(value)) {
//           value = "$" + value;
//         }
//         state.lookahead_buffer.push_back(Token(location, value, TType::Identifier, TFamily::Identifier));
//       }
//       return;
//     } else if (std::ispunct(c)) {
//       std::string longest_match;
//       std::string current_match;
//       while (pos < len && std::ispunct(c)) {
//         if (c == '\"') {
//           break;
//         }
//         current_match += input[pos];
//         if (operators.find(current_match) != operators.end()) {
//           longest_match = current_match;
//         } else {
//           if (!longest_match.empty()) {
//             state.lookahead_buffer.push_back(
//                 Token(location, longest_match, operators.at(longest_match), TFamily::Operator));
//             return;
//           }
//         }
//         pos++;
//         col++;
//         c = input[pos];
//       }

//       if (!longest_match.empty()) {
//         state.lookahead_buffer.push_back(
//             Token(location, longest_match, operators.at(longest_match), TFamily::Operator));
//         return;
//       } else {
//         throw_error("unable to lex operator :: '" + current_match + '\'', {location});
//       }
//     } else if (std::isdigit(c)) {
//       bool is_float = false;
//       bool is_hex = false;
//       bool is_bin = false;
//       if (c == '0' && (input[pos + 1] == 'x' || input[pos + 1] == 'X')) {
//         is_hex = true;
//         pos += 2; // Skip '0x'
//         col += 2;
//         c = input[pos];
//       } else if (c == '0' && (input[pos + 1] == 'b' || input[pos + 1] == 'B')) {
//         is_bin = true;
//         pos += 2; // Skip '0b'
//         col += 2;
//         c = input[pos];
//       }

//       while (pos < len && (std::isdigit(c) || c == '.' || (is_hex && std::isxdigit(c)) ||
//                            (is_bin && (c == '0' || c == '1')) || c == '_')) {
//         if (c == '_') {
//           pos++;
//           col++;
//           c = input[pos];
//         }
//         if (c == '.' && pos + 1 < len && input[pos + 1] == '.') {
//           break;
//         }
//         if (c == '.') {
//           if (is_float) {
//             throw_error("got too many '.' periods in a float literal.", {location});
//           }
//           is_float = true;
//         }
//         token.put(c);
//         pos++;
//         col++;
//         c = input[pos];
//         if (c == '_') {
//           pos++;
//           col++;
//           c = input[pos];
//         }
//       }
//       auto value = token.str();

//       if (is_hex) {
//         state.lookahead_buffer.push_back(Token(location, "0x" + value, TType::Integer, TFamily::Literal));
//       } else if (is_bin) {
//         state.lookahead_buffer.push_back(Token(location, "0b" + value, TType::Integer, TFamily::Literal));
//       } else if (!is_float) {
//         state.lookahead_buffer.push_back(Token(location, value, TType::Integer, TFamily::Literal));
//       } else {
//         state.lookahead_buffer.push_back(Token(location, value, TType::Float, TFamily::Literal));
//       }
//       return;
//     } else {
//       throw_error("unable to lex character :: '" + std::string(1, c) + '\'', {location});
//     }
//   }
//   state.lookahead_buffer.push_back(Token::Eof());
// }
//   }
// }

