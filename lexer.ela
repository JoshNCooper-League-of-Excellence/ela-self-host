import map::*;
import fmt::*;

TType :: enum {
  Eof = -1,
  Identifier,
  Integer,
  Float,
  String,
  Char,

  Assign,
  Add,
  Sub,
  Mul,
  Div,
  Modulo,
  Range,
  Arrow,
  Comma,
  Semi,

  Not,
  LogicalNot,
  Or,
  And,
  SHL,
  SHR,
  Xor,
  LogicalOr,
  LogicalAnd,
  LT,
  GT,
  EQ,
  NEQ,
  LE,
  GE,
  LParen,
  RParen,
  LCurly,
  RCurly,
  LBrace,
  RBrace,
  DoubleColon,
  Dot,

  Increment,
  Decrement,

  Return,
  Break,
  Continue,
  For,
  While,
  If,
  Else,

  CompAdd,
  CompSub,
  CompMul,
  CompDiv,
  CompMod,
  CompAnd,
  CompOr,
  CompXor,
  CompSHL,
  CompSHR,

  True,
  False,
  Null,
  Varargs,
  Directive,   // #
  ColonEquals, //  :=

  Struct,
  Enum,
  Union,

  Then,
  Colon,
  In,

  Switch,
  Fn,

  GenericBrace,   // '!<' for ![T, T1]
  As,             // 'as' for casting
  ExpressionBody, // => for expr body, implicit return expr where a block was otherwise expected.
  Defer,

  Impl,      // impl
  Interface, // interface
  Where,

  Size_Of,
  Type_Of,

  Alias,
  Import,
  Module,

  Attribute,

  Mut,
  Const
}

init_ttype_lut :: fn() -> Map!<u64, str> {
  type := typeof(TType);
  mut lut: Map!<u64, str>;
  for field in type.fields {
    lut.insert(field.enum_value, field.name);
  }
  return lut;
}

ttype_to_string :: fn(type: TType) -> str {
  #static mut lut: *mut Map!<u64, str>;
  if !lut {
    lut = new(init_ttype_lut());
  }
  return lut.get(type).unwrap();
}

SourceLocation :: struct {
  line: u64,
  column: u64,
  file: u64,
}

impl SourceLocation {
  #static files :: fn() -> *mut Map!<u64, String> {
    #static mut files: Map!<u64, String>;
    return &mut files;
  }

  to_string :: fn(self) -> String {
    filename := SourceLocation::files().get(self.file).unwrap();
    return format("%:%:%", (filename, self.line, self.column), FormatOptions::default());
  }
}

struct Token {
  inline bool is_relational() const {
    switch (type) {
      case TType::LT:
      case TType::GT:
      case TType::EQ:
      case TType::NEQ:
      case TType::LE:
      case TType::GE:
      case TType::LogicalOr:
      case TType::LogicalAnd:
        return true;
      default:
        return false;
    }
  }
  inline bool is_comp_assign() const {
    return type == TType::CompAdd || type == TType::CompSub || type == TType::CompMul || type == TType::CompDiv ||
           type == TType::CompMod || type == TType::CompAnd || type == TType::CompOr || type == TType::CompXor ||
           type == TType::CompSHL || type == TType::CompSHR;
  }

  Token() {}

  Token(SourceLocation location, InternedString value, TType type, TFamily family)
      : value(std::move(value)), type(type), family(family), location(location) {}
  InternedString value;
  TType type;
  TFamily family;
  SourceLocation location;
  static Token &Eof() {
    static Token eof = Token(SourceLocation(0, 0, 0), {""}, TType::Eof, TFamily::Operator);
    return eof;
  }

  bool is_eof() const { return type == TType::Eof; }
};

static std::unordered_map<std::string, TType> keywords{
    {"const", TType::Const},
    {"mut", TType::Mut},

    {"module", TType::Module},

    {"import", TType::Import},
    {"импорт", TType::Import},

    {"alias", TType::Alias},
    {"псевдоним", TType::Alias},

    // control flow
    {"in", TType::In},
    {"в", TType::In},

    {"where", TType::Where},
    {"где", TType::Where},

    {"sizeof", TType::Size_Of},
    {"кегль", TType::Size_Of},

    {"typeof", TType::Type_Of},
    {"тип", TType::Type_Of},

    {"fn", TType::Fn},
    {"фн", TType::Fn},

    {"switch", TType::Switch},
    {"матч", TType::Switch},

    {"then", TType::Then},
    {"тогда", TType::Then},

    {"return", TType::Return},
    {"возврат", TType::Return},

    {"break", TType::Break},
    {"прерв", TType::Break},

    {"continue", TType::Continue},
    {"продолжать", TType::Continue},

    {"for", TType::For},
    {"для", TType::For},

    {"while", TType::While},
    {"пока", TType::While},

    {"if", TType::If},
    {"если", TType::If},

    {"else", TType::Else},
    {"ещё", TType::Else},

    // type declarations
    {"struct", TType::Struct},
    {"структ", TType::Struct},

    {"union", TType::Union},
    {"союз", TType::Union},

    {"enum", TType::Enum},
    {"перечень", TType::Enum},

    // literals
    {"true", TType::True},
    {"правда", TType::True},

    {"false", TType::False},
    {"неверим", TType::False},

    {"null", TType::Null},
    {"нулевой", TType::Null},

    // miscellaneous
    {"as", TType::As},
    {"как", TType::As},

    {"impl", TType::Impl},
    {"реализуйте", TType::Impl},

    {"defer", TType::Defer},
    {"отложить", TType::Defer},

    {"interface", TType::Interface},
    {"интерфейс", TType::Interface},
};

static std::unordered_map<std::string, TType> operators{{"=>", TType::ExpressionBody},
                                                        {":", TType::Colon},
                                                        {"@", TType::Attribute},
                                                        {":=", TType::ColonEquals},
                                                        {"...", TType::Varargs},
                                                        {"#", TType::Directive},
                                                        {".", TType::Dot},
                                                        {"!", TType::LogicalNot},
                                                        {"~", TType::Not},
                                                        {"::", TType::DoubleColon},
                                                        {"->", TType::Arrow},
                                                        {"..", TType::Range},
                                                        {"+", TType::Add},
                                                        {"-", TType::Sub},
                                                        {"*", TType::Mul},
                                                        {"/", TType::Div},
                                                        {"%", TType::Modulo},
                                                        {"=", TType::Assign},
                                                        {",", TType::Comma},
                                                        {";", TType::Semi},
                                                        {"(", TType::LParen},
                                                        {")", TType::RParen},
                                                        {"{", TType::LCurly},
                                                        {"}", TType::RCurly},
                                                        {"|", TType::Or},
                                                        {"&", TType::And},
                                                        {"||", TType::LogicalOr},
                                                        {"&&", TType::LogicalAnd},
                                                        {"<<", TType::SHL},
                                                        {"^", TType::Xor},
                                                        {"<", TType::LT},
                                                        {">", TType::GT},
                                                        {"==", TType::EQ},
                                                        {"!=", TType::NEQ},
                                                        {"<=", TType::LE},
                                                        {">=", TType::GE},
                                                        {"[", TType::LBrace},
                                                        {"]", TType::RBrace},
                                                        {"++", TType::Increment},
                                                        {"--", TType::Decrement},
                                                        {"+=", TType::CompAdd},
                                                        {"-=", TType::CompSub},
                                                        {"*=", TType::CompMul},
                                                        {"/=", TType::CompDiv},
                                                        {"%=", TType::CompMod},
                                                        {"&=", TType::CompAnd},
                                                        {"|=", TType::CompOr},
                                                        {"^=", TType::CompXor},
                                                        {"<<=", TType::CompSHL},
                                                        {">>=", TType::CompSHR},
                                                        {"!<", TType::GenericBrace}};

struct Lexer {
  struct State {
    bool operator==(const Lexer::State &other) const { return other.input == input; }

    State(const std::string &input, size_t file_idx, size_t input_len, const std::filesystem::path &path)
        : input(input), file_idx(file_idx), path(path), input_len(input_len) {}

    std::string input{};
    std::filesystem::path path;
    std::deque<Token> lookahead_buffer{};
    size_t pos = 0;
    size_t col = 1;
    size_t line = 1;
    size_t file_idx{};
    size_t input_len{};

    static State from_string(const std::string &input) { return State(input, 0, input.length(), ""); }

    static State from_file(const std::string &filename) {
      auto canonical = std::filesystem::canonical(filename);
      auto path = canonical.string();
      std::filesystem::current_path(canonical.parent_path());

      if (!std::filesystem::exists(canonical)) {
        printf("File %s does not exist. Quitting..", canonical.string().c_str());
        exit(1);
      }

      std::ifstream file(canonical);
      std::stringstream ss;
      ss << file.rdbuf();
      auto input = ss.str();

      bool found = false;
      size_t file_idx = 0;
      for (const auto &file : SourceLocation::files()) {
        if (file == path) {
          found = 1;
        } else {
          ++file_idx;
        }
      }
      if (!found) {
        SourceLocation::files().push_back(path);
      }
      return State(input, file_idx, input.length(), canonical);
    }
  };

  void get_token(State &state);
};
