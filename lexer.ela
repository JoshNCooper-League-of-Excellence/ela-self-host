import map::*;
import fmt::*;
import fs::*;

alias InternedString :: Interned!<String>;

TType :: enum {
  Eof = -1,
  Identifier,
  Integer,
  Float,
  String,
  Char,

  Assign,
  Add,
  Sub,
  Mul,
  Div,
  Modulo,
  Range,
  Arrow,
  Comma,
  Semi,

  Not,
  LogicalNot,
  Or,
  And,
  SHL,
  SHR,
  Xor,
  LogicalOr,
  LogicalAnd,
  LT,
  GT,
  EQ,
  NEQ,
  LE,
  GE,
  LParen,
  RParen,
  LCurly,
  RCurly,
  LBrace,
  RBrace,
  DoubleColon,
  Dot,

  Increment,
  Decrement,

  Return,
  Break,
  Continue,
  For,
  While,
  If,
  Else,

  CompAdd,
  CompSub,
  CompMul,
  CompDiv,
  CompMod,
  CompAnd,
  CompOr,
  CompXor,
  CompSHL,
  CompSHR,

  True,
  False,
  Null,
  Varargs,
  Directive,   // #
  ColonEquals, //  :=

  Struct,
  Enum,
  Union,

  Then,
  Colon,
  In,

  Switch,
  Fn,

  GenericBrace,   // '!<' for ![T, T1]
  As,             // 'as' for casting
  ExpressionBody, // => for expr body, implicit return expr where a block was otherwise expected.
  Defer,

  Impl,      // impl
  Interface, // interface
  Where,

  Size_Of,
  Type_Of,

  Alias,
  Import,
  Module,

  Attribute,

  Mut,
  Const
}

init_ttype_lut :: fn() -> Map!<u64, str> {
  type := typeof(TType);
  mut lut: Map!<u64, str>;
  for field in type.fields {
    lut.insert(field.enum_value, field.name);
  }
  return lut;
}

ttype_to_string :: fn(type: TType) -> str {
  #static mut lut: *mut Map!<u64, str>;
  if !lut {
    lut = new(init_ttype_lut());
  }
  return lut.get(type).unwrap();
}

SourceLocation :: struct {
  line: u64,
  column: u64,
  file: u64,
}

impl SourceLocation {
  #static files :: fn() -> *mut List!<String> {
    #static mut files: List!<String>;
    return &mut files;
  }

  to_string :: fn(self) -> String {
    filename := SourceLocation::files()[self.file];
    return format("%:%:%", (filename, self.line, self.column), FormatOptions::default());
  }
}

Token :: struct {
  value: InternedString,
  type: TType,
  location: SourceLocation,
}

impl Token {
  is_relational :: fn(self) -> bool{
    return switch self.type {
      TType::LT => true,
      TType::GT => true,
      TType::EQ => true,
      TType::NEQ => true,
      TType::LE => true,
      TType::GE => true,
      TType::LogicalOr => true,
      TType::LogicalAnd => true,
      else => false,
    }
  }

  is_comp_assign :: fn(self) -> bool  {
    return self.type == TType::CompAdd || self.type == TType::CompSub || self.type == TType::CompMul || self.type == TType::CompDiv ||
           self.type == TType::CompMod || self.type == TType::CompAnd || self.type == TType::CompOr || self.type == TType::CompXor ||
           self.type == TType::CompSHL || self.type == TType::CompSHR;
  }

  #static Eof :: fn() -> Token {
    #static eof: Token = .{
      type: TType::Eof,
    };
    return eof;
  }

  is_type :: fn(self, type: TType) -> bool {
    return self.type == type;
  }

  is_eof :: fn(self) -> bool {
    return self.type == TType::Eof;
  }
};

init_operator_and_keyword_maps :: fn(operators: *mut Map!<str, TType>, keywords: *mut Map!<str, TType>) {
  keywords.insert("const", TType::Const);
  keywords.insert("mut", TType::Mut);
  keywords.insert("module", TType::Module);
  keywords.insert("import", TType::Import);
  keywords.insert("alias", TType::Alias);
  keywords.insert("in", TType::In);
  keywords.insert("where", TType::Where);
  keywords.insert("sizeof", TType::Size_Of);
  keywords.insert("typeof", TType::Type_Of);
  keywords.insert("fn", TType::Fn);
  keywords.insert("switch", TType::Switch);
  keywords.insert("then", TType::Then);
  keywords.insert("return", TType::Return);
  keywords.insert("break", TType::Break);
  keywords.insert("continue", TType::Continue);
  keywords.insert("for", TType::For);
  keywords.insert("while", TType::While);
  keywords.insert("if", TType::If);
  keywords.insert("else", TType::Else);
  keywords.insert("struct", TType::Struct);
  keywords.insert("union", TType::Union);
  keywords.insert("enum", TType::Enum);
  keywords.insert("true", TType::True);
  keywords.insert("false", TType::False);
  keywords.insert("null", TType::Null);
  keywords.insert("as", TType::As);
  keywords.insert("impl", TType::Impl);
  keywords.insert("defer", TType::Defer);
  keywords.insert("interface", TType::Interface);

  operators.insert("=>", TType::ExpressionBody);
  operators.insert(":", TType::Colon);
  operators.insert("@", TType::Attribute);
  operators.insert(":=", TType::ColonEquals);
  operators.insert("...", TType::Varargs);
  operators.insert("#", TType::Directive);
  operators.insert(".", TType::Dot);
  operators.insert("!", TType::LogicalNot);
  operators.insert("~", TType::Not);
  operators.insert("::", TType::DoubleColon);
  operators.insert("->", TType::Arrow);
  operators.insert("..", TType::Range);
  operators.insert("+", TType::Add);
  operators.insert("-", TType::Sub);
  operators.insert("*", TType::Mul);
  operators.insert("/", TType::Div);
  operators.insert("%", TType::Modulo);
  operators.insert("=", TType::Assign);
  operators.insert(",", TType::Comma);
  operators.insert(";", TType::Semi);
  operators.insert("(", TType::LParen);
  operators.insert(")", TType::RParen);
  operators.insert("{", TType::LCurly);
  operators.insert("}", TType::RCurly);
  operators.insert("|", TType::Or);
  operators.insert("&", TType::And);
  operators.insert("||", TType::LogicalOr);
  operators.insert("&&", TType::LogicalAnd);
  operators.insert("<<", TType::SHL);
  operators.insert("^", TType::Xor);
  operators.insert("<", TType::LT);
  operators.insert(">", TType::GT);
  operators.insert("==", TType::EQ);
  operators.insert("!=", TType::NEQ);
  operators.insert("<=", TType::LE);
  operators.insert(">=", TType::GE);
  operators.insert("[", TType::LBrace);
  operators.insert("]", TType::RBrace);
  operators.insert("++", TType::Increment);
  operators.insert("--", TType::Decrement);
  operators.insert("+=", TType::CompAdd);
  operators.insert("-=", TType::CompSub);
  operators.insert("*=", TType::CompMul);
  operators.insert("/=", TType::CompDiv);
  operators.insert("%=", TType::CompMod);
  operators.insert("&=", TType::CompAnd);
  operators.insert("|=", TType::CompOr);
  operators.insert("^=", TType::CompXor);
  operators.insert("<<=", TType::CompSHL);
  operators.insert(">>=", TType::CompSHR);
  operators.insert("!<", TType::GenericBrace);
}

State :: struct {
  input: String,
  path: String,
  lookahead_buffer: List!<Token>,
  pos: u64,
  col: u64,
  line: u64,
  file_idx: u64,
}

impl State {
  new :: fn(path: String, input: String, file_idx: u64) -> #self {
    return .{
      path: path,
      input: input,
      file_idx: file_idx,
      pos: 0,
      col: 1,
      line: 1,
    };
  }

  from_file :: fn(filename: String) -> #self {
      canonical := canonical_path(filename).unwrap();
      parent := parent_path(canonical).unwrap();
      change_directory(parent).unwrap();
      input := File::read_all(canonical).unwrap();

      mut found := false;
      mut file_idx := 0;
      for file in *SourceLocation::files() {
        if file == canonical {
          found = true;
          break;
        } 
        file_idx++;
      }
      if (!found) {
        SourceLocation::files().push(canonical);
      }
      return State::new(canonical, input, file_idx);
    }
}

get_next_token :: fn(state: State) {

}
