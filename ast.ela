import lexer::*;
import arena::{
  Arena,
  ArenaFlags
};

alias TypeID :: u32;


ExprTag :: enum {
  Literal, // identifiers, numeric / string literals, etc.
  Unary,   // negate, not, etc
  Binary,  // + - % / ^ etc.
  Postfix, // dot expression, subscript/index, call.
}

Expr :: struct {
  location: SourceLocation,
  tag: ExprTag,
  data: *mut void,
}

impl Expr {
  new :: fn(location: SourceLocation, tag: ExprTag, data: *mut void) -> Expr {
    return .{
      location: location,
      tag: tag,
      data: data,
    }
  }
}

LiteralTag :: enum {
  Identifier,
  Integer,
  Float,
  Bool,
  CString,
  String,
  Char,
  Null,
}

ExprLiteral :: struct {
  tag:   LiteralTag,
  value: InternedString,
}

ExprUnary :: struct {
  left: Expr,
  operator: TType,
}

ExprBinary :: struct {
  left: Expr,
  right: Expr,
  operator: TType,
}

ExprDot :: struct {
  left: Expr,
  member: InternedString,
}

ExprScopeResolution :: struct {
  left: Expr,
  member: InternedString,
}

ExprIndex :: struct {
  left: Expr,
  index: Expr,
}

ExprCall :: struct {
  left: Expr,
  arguments: List!<Expr>,
}

PostfixTag :: enum {
  Dot,
  Index,
  Call,
  ScopeResolution,
}

ExprPostfix :: struct {
  tag: PostfixTag,
  #anon :: union {
    dot: ExprDot,
    index: ExprIndex,
    call: ExprCall,
    scope_resolution: ExprScopeResolution,
  }
}

parse_literal :: fn(value: str) -> ExprLiteral {
  return .{
    tag: LiteralTag::Integer,
    value: InternedString::new(String::from(value)),
  };

}

main :: fn() {
  mut left := parse_literal("0");
  mut right := parse_literal("1");
  binary := ExprBinary.{
    left: Expr::new(.{}, ExprTag::Literal, new(left)),
    left: Expr::new(.{}, ExprTag::Literal, new(right)),
    operator: TType::Add,
  };
}

/* 
  Nodes in our old compiler that have references to statements and inherit from statement themselves:
  ASTBlock
  ASTProgram
  ASTStatementList
  ASTModule
  ASTDefer
*/

