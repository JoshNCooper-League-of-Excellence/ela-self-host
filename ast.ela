import lexer::*;
import arena::{
  Arena,
  ArenaFlags
};

alias TypeID :: u32;

ExprTag :: enum {
  // identifiers, numeric / string literals, etc.
  Literal, 
  // negate, not, etc
  Unary,   
  // + - % / ^ etc.
  Binary,  
  // dot expression, subscript/index, call.
  // x.value, x.get(0), x[10]; etc.
  Postfix, 
  // tuple literals don't fit into the 
  // literal struct because they don't 
  // have a simple textual representation
  // (0, 1, 2)
  Tuple,
  // Range literals, have the same problem as tuples. 
  // so they must be their own expression unfortunately.
  // 0..10
  Range,
  // .{}, .{x: x, y: y}, 
  StructInitializer,
  // .[], .[0, 1, 23]
  CollectionInitializer,
  // x as s32
  Cast,
  // fn() -> bool => false;
  Lambda,
  // sizeof(s32) :: compile time type sizing.
  SizeOf,
  // typeof(s32) :: reflection
  TypeOf,
  /* 
    getter :: fn!<T, Other>() where T: Sized, 
           Other: List!<T> { ... }
  */
  Where,
}

Expr :: struct {
  type: TypeID,
  location: SourceLocation,
  tag: ExprTag,
  data: *mut void,
}

impl Expr {
  new :: fn(location: SourceLocation, tag: ExprTag, data: *mut void) -> Expr {
    return .{
      location: location,
      tag: tag,
      data: data,
    }
  }
}

LiteralTag :: enum {
  Identifier,
  Integer,
  Float,
  Bool,
  CString,
  String,
  Char,
  Null,
}

ExprLiteral :: struct {
  tag:   LiteralTag,
  value: InternedString,
}

ExprUnary :: struct {
  left: Expr,
  operator: TType,
}

ExprBinary :: struct {
  left: Expr,
  right: Expr,
  operator: TType,
}

ExprDot :: struct {
  left: Expr,
  member: InternedString,
}

ExprScopeResolution :: struct {
  left: Expr,
  member: InternedString,
}

ExprIndex :: struct {
  left: Expr,
  index: Expr,
}

ExprCall :: struct {
  left: Expr,
  arguments: List!<Expr>,
}

PostfixTag :: enum {
  Dot,
  Index,
  Call,
  ScopeResolution,
}

ExprPostfix :: struct {
  tag: PostfixTag,
  #anon :: union {
    dot: ExprDot,
    index: ExprIndex,
    call: ExprCall,
    scope_resolution: ExprScopeResolution,
  }
}

ExprTuple :: struct {
  values: List!<Expr>,
}

ExprRange :: struct {
  begin: Expr, 
  end: Expr, 
  inclusive: bool, // include the last value. 0..=100 would go 0->100, whereas 0..100 goes 0->99
}

ExprSizeOf :: struct {
  type: Expr,
}

ExprTypeOf :: struct {
  type: Expr,
}

ExprStructInitializer :: struct {
  target: Option!<Expr>, // if we do Type.{}, 'Type' would be our target.
  members: Map!<InternedString, Expr>,
}

ExprCollectionInitializer :: struct {
  target: Option!<Expr>, // if we do Type.[], 'Type' would be our target.
  members: List!<Expr>,
}

ExprCast :: struct {
  // x + 2 as s32;
  //          ^^^<- target.
  // ^^^^^<- expression.
  target: Expr, 
  expression: Expr,
}

ExprLambda :: struct {
  // TODO:  We don't have function declarations fleshed out yet. We'll wait on that.
}

ExprType :: struct {
  // TODO: we don't have our type system written either. We're going to do that now, but until then,
  // TODO: we can't really make a solid design here.
}

/* 
  Nodes in our old compiler that have references to statements and inherit from statement themselves:
  ASTBlock
  ASTProgram
  ASTStatementList
  ASTModule
  ASTDefer
*/

